{"version":3,"file":"static/webpack/static/development/pages/index.js.c61c52f21d92d26e54a3.hot-update.js","sources":["webpack:///./util/index.js"],"sourcesContent":["\nconst computeUnion = (a1, a2) => {\n  let union = [];\n  let arry = a1;\n  arry.sort();\n  union.concat([], a1);\n  union = a2.eles.reduce((acc, i) => {\n    const index = binaryIndexOf(arry, i);\n    if(index === -1) {\n      acc.push(i);\n    }\n    return acc;\n  }, []);\n  const range = [...a2.range];\n  range.sort();\n  if(range[0] < arry[0]) {\n    union = [].concat([...new Array(arry[0] - range[0])].map((ele, i) => i + range[0]), union);\n  }\n  if(range[0] > arry[0] && binaryIndexOf(arry, range[0]) === -1) {\n    union = [].concat(union, range[0]);\n  }\n  if(arry[arry.length - 1] < range[1]) {\n    union = [].concat(union, [...new Array(range[1] + 1 - arry[arry.length - 1] + 1)].map((ele, i) => i + arry[arry.length - 1]));\n  }\n  if(arry[arry.length - 1] > range[1] && binaryIndexOf(arry, range[1]) === -1) {\n    union = [].concat(union, range[1]);\n  }\n  return union.sort();\n};\n\nconst binaryIndexOf = (arry, searchElement) => {\n  let minIndex = 0;\n  let maxIndex = arry.length - 1;\n  let currentIndex;\n  let currentElement;\n\n  while (minIndex <= maxIndex) {\n    currentIndex = (minIndex + maxIndex) / 2 | 0;\n    currentElement = arry[currentIndex];\n\n    if (currentElement < searchElement) {\n      minIndex = currentIndex + 1;\n    }\n    else if (currentElement > searchElement) {\n      maxIndex = currentIndex - 1;\n    }\n    else {\n      return currentIndex;\n    }\n  }\n\n  return -1;\n};\n\nconst indexOfMaxLessThan = (a, ele) => {\n  let max = Number.MAX_SAFE_INTEGER, index = 0;\n  for(var i= 0; i < a.length; i++) {\n    if(a[i] < ele && a[i] > max){\n      max = a[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\nconst indexOfMinGreaterThan = (a, ele) => {\n  let min = Number.MIN_SAFE_INTEGER, index = 0;\n  for(var i= 0; i < a.length; i++) {\n    if(a[i] > ele && a[i] < min){\n      min = a[i];\n      index = i;\n    }\n  }\n  return index;\n}\n\nconst computeIntersecion = (a1, a2) => {\n  let arry = a1;\n  arry.sort();\n  let intersecion = [];\n  intersecion = a2.reduce((acc, i) => {\n    const index = binaryIndexOf(arry, i);\n    if(index !== -1) {\n      acc.push(i);\n    }\n  }, []);\n  const range = [...a2.range];\n  range.sort();\n  if(range[0] < arry[0] && range[1] > arry[arry.length - 1]) {\n    return intersecion;\n  }\n  if(range[0] < arry[0] && range[1] < arry[arry.length - 1]) {\n    const index = indexOfMaxLessThan(arry, range[1]);\n    return intersecion.slice(0, index + 1);\n  }\n  if(range[0] > arry[0] && range[1] > arry[arry.length - 1]) {\n    const index = indexOfMinGreaterThan(arry, range[0])\n  }\n}\nexport default {\n  binaryIndexOf,\n  computeUnion,\n  computeIntersecion\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;;;;A","sourceRoot":""}